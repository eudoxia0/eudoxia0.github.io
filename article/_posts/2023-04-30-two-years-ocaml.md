---
title: Two Years of OCaml
summary: My thoughts on OCaml after two years of building a compiler with it.
---

- intro
    - the other day I saw this post: <https://osa1.net/posts/2023-04-24-ocaml-thoughts.html>
        - discussed on HN: https://news.ycombinator.com/item?id=35699697
        - and lobsters: https://lobste.rs/s/jvxb8s/my_thoughts_on_ocaml
    - thought i might give my two cents
        - austral compiler was ported from sml to ocaml almost two years ago
        - my experience using ocaml for the past two years
        - how it compares to standard ml
        - how it compares to haskell
- syntax
    - disclaimers
        - de gustibus yadda yadda
        - I am not a partisan about syntax.
        - I genuinely think C, Java, Lisp, Pascal and ML can be beautiful in their own ways.
    - aesthetics
        - good for math
        - bad for everything else
        - ML syntax feels like it's "hanging in the air"
        - expression orientation cuts both ways
            - pro: simple and general
            - cons: it's easy to create complicated, arbitrarily nested code
                - requires discipline to avoid doing this
                - statement oriented languages force you to flatten things
    - declaration order
        - the following code
            - example
        - will not compile, you have to rewrite it like this
            - example
        - to have the declarations appear in order. alternatively, you can use an and chain
            - example
        - same is true for types
        - and chains let you put declarations in the right order
        - having an entire module be a `let rec ... and ... and ... and` feels brittle
        - you also can't interleave functions and types
        - so you have to put all your types upfront
    - currying is bad
        - punctuation is good
        - adjacency is not syntax
        - it's "cute"
        - comes at a high cost
        - every time you
            - forget an argument
            - add an argument
            - mess up argument order
        - you don't get an error to that effect
            - rather, you get a type error that is a consequence of your mistake
        - you learn gradually to pattern-match error messages to actual errors
            - if you see an error like "something something is a function typoe", you forgot a type
            - if you see an error like "foo is not a function type", you added an extra type
        - You can avoid it with tuples but it makes type annotations harder
    - awkward comment syntax
        - no single-line comment syntax
        - only block comments
        - `(* derp *)` is torture to write
        - comments can be nested, as in Common Lisp, which is good for commenting-out large chunks of code
    - type annotation syntax
        - inconsistent
            - tuples
                - `a * b` is a type
                - `(a, b)` is a tuple constructor
                - haskell does this right
            - generics are kinda weird
                - `int list` means `list[int]`
                - modern languages have converged on a notation like `name[tyarg, ..., tyarg]`.
                - haskell not much better: `Maybe Int`. For the love of God: give me punctuation.
    - semicolons work sometimes
        - semicolons are, as you'd expect, for sequencing
        - example that works
        - example that doesn't work
        - makes it hard to insert a debugging print somewhere
    - weirdnesses
        - as above: tuple type vs. tuple constructor
        - tuple is `(a,b,c)` list is `[a;b;c]`
        - i guess `,` is an infix operator or something
    - nested match statements
        - which appear everywhere
        - have to be parenthesized, so larger functions end up looking lisp-ish with a chain of close parentheses at the end
            - you can avoid this by refactoring each match into a separate function, but then you get the long and chains
    - vs. haskell
        - Haskell is better:
            - separating type annotations
            - less custom syntax
            - no declaration order
            - fine-grained imports
        - Haskell is worse:
            - those dreadful infix operators
            - indentation sensitivity
    - conservative ocaml
        - my ocaml vs. all the ocaml i see in the wild
    - ppx
    - at least it's not haskell
    - how the fuck do i profile
    - docs are useless if i can't find them
    - tooling
        - kinda works sometimes
    - modules: better is worse
        - what they are
        - modules hide too much
        - equality is a special case
            - shows things are bad
            - have the courage of your convictions
        - implicit specialization is good
        - integer ordering by divisibility
        - ad-hoc or generic
            - unclear when to use generic types and when to specialize
    - perry's comments
    - the attic
        - all sorts of language features
    - compare returns an int
- When to use OCaml?