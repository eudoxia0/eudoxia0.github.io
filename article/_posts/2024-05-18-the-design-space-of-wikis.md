---
title: The Design Space of Wikis
summary: etc.
---

- object structure
  - what kinds of data do objects hold?
  - plain text
    - an object's contents are plain, unformatted text
    - plain text conventions are used for "formatting"
    - links are just text
  - plain text with links
    - plain text
    - but with specific markup for links
  - formatted text
    - simple formatting: bold, lists, etc.
  - rich text with metadata
    - example: notion
    - typed properties aside from the text
    - "main text" remains a privileged own thing
  - typed properties
    - "main text" no longer a privileged thing
    - an object is a map of property names to values
    - some values may be rich text
  - mixin: fixed-length content
    - to simulate the limitations of paper
    - content may be limited to some fixed length
    - examples: none that i know of
- identifiers
  - unreadable identifiers
    - uuids
    - make it possible to rename things in a consequence free fashion
    - usually have to be hidden, requires WYSIWYG editing and a database
    - examples: notion
  - unique title
    - the object title is globally unique
    - this makes it easy to reference objects in a plain-text wiki: you just write the name
    - examples: wikipedia
  - file path
    - can rename the title, without affecting anything
    - linking has to include the filename rather than the more human readable page name
    - reorganizing the folder structure breaks the link structure
- organization
  - how are objects organized?
  - none
    - objects exist in the aether
    - can be found by searching, or linking to other objects
  - boxes
    - examples:
      - xerox notecards
      - reality
    - there's a list of fileboxes, and objects exist in the filebox
  - list
    - objects exist in an ordered list
    - example: card files
  - folders
    - very common
    - examples: obsidian
    - objects exist in hierarchically-structured folders
    - folders and objects are distinct
  - folder-page unification
    - examples: notion
    - this is a really useful feature that for some reason is rarely implemented
    - a page can have sub-pages
    - there is no special category of "folder"
    - in obsidian i'm often bothered by the fact that i'd like to have something like an "index" page for a folder
    - that can act as the atlas, or description, of the folder's contents
    - notion lets you have that
  - tags
    - give up the hierarchy
    - information can be tagged and found through boolean operations on tags
  - pure hypertext
    - examples: roam
    - give up the hierarchy
    - only way to find things is clicking a link, or search
    - pros:
      - strictly more general than hierarchy
    - cons:
      - does not appeal to spatial intuition
  - spatially
    - objects exist on a canvas you can pan or scroll
    - pros:
      - appeals to the human intuition
    - cons:
      - infinite zoom in/out is non-physical
- storage
  - files
    - plain-text files in a folder
      - edited with your choice of editor
      - the UI can be read-write (obsidian, gitit)
      - or read-only, e.g. serving HTML or even compiling to static HTML, like any static site generator
    - examples:
      - obsidian
      - jekyll and any ssg
      - ikiwiki
      - gitit
    - there's two ways to do this:
      - the client "owns" the git repo, and makes commits
        - e.g. gitit, ikiwiki
      - the client just reads from, and writes to, the repo, but does not make commits
        - e.g. obsidian
    - pros
      - version control for free
        - can track changes in git
      - change review
        - for collaborative wikis, changes can be proposed in PRs
      - multi-file changes
        - with git, changes can apply to multiple files
          - this is unique to git
      - file generation
        - can do cool things with makefiles
        - e.g. generate pages from some source of truth data
        - transclusion
        - compilation into different formats
        - e.g. say you have some corporate policies
          - you can have the markdown files in the wiki be the source of truth
          - and a makefile to transclude them and compile them to a PDF
          - to upload e.g. to a compliance management platform
        - dually, you can turn files from the filesystem into database pages
          - you can have a CSV file with your reading list
          - and a makefile to compile that into like one page per entry
      - bring your own tools
        - can edit in emacs or vim or zed or vscode or whatever editor you want
      - durable
        - plain text files are gonna last longer than some proprietary format
        - can be read from and written to with standard tools
    - cons
      - visibility
        - auth for git repos is repo-wide
        - you can either view the entire repo, or none of it
      - two-app failure modes:
        - if one app is used to write, and another to view, the latter tends to be ignored
        - the reason is if you are editing files through e.g. a text editor, you have to be able to find that file by browsing
        - therefore the editor can browse, read, edit, and search the files
        - what does the viewer do?
        - it provides a cute interface, maybe higher-level search, it renders tex math, and maybe it can do things like queries over the database (liek notion views)
        - in my experience of using jekyll as a person wiki, i only actually launched the wiki when I wanted to view rendered tex math
        - otherwise I'd just use Zed or Emacs to read and write
        - it helps that markdown is very readable like that
        - obsidian doesn't have this because the viewer is also a very convenient editor
          - it never occurs to me to edit an obsidian vault with Emacs
          - this might interact poorly with e.g. version control
      - sync is harder
        - using the thing from e.g. your phone is harder, you need git and the filesystem
      - visibility of changes
        - changes are stuck in the git history
        - may not be easy to make them visible to the application
  - database
    - objects are stored in a database
    - manipulation is through a client application
    - object histories are kept in the database, if any
    - pros:
      - hostable:
        - if there's a database and a server, the app can be hosted somewhere and accessed over the internet
        - can use from multiple devices, from your phone etc.
      - security:
        - for teams, custom permissions and visibility rules can be implemented by the server
        - examples: notion
      - renaming:
        - objects can be given database IDs and referred to by those IDs
        - renaming can be done transparently, without breaking anything
      - free structure:
        - files in a git repo, the folder structure has to make it easy to browse, so that files can be found for editing
        - it's natural that the folder structure should be visible in the client application (how obsidian works)
        - in a database, the storage system does not have to dictate how pages are organized
        - can have any kind of organization at the application layer
      - VC is built in
        - version control does not have to involve a separate app
      - single client
        - there is one way to interact with the wiki's contents
        - don't need a text editor and a viewer as separate apps
    - cons:
      - portability:
        - plain-text markdown files are more readable than a database schema
        - sqlite is portable enough but there's extra layers of friction
          - install the sqlite client
          - figure out the database schema
          - figure out queries to get/insert the information you want
      - custom client:
        - unlike plain text files, you can't edit this with e.g Emacs
        - need a custom client software
      - cant interact with files
        - data is stuck in the database
        - extracting data into files is hard
        - importing data from files is hard
      - version control
        - needs to be reimplemented
- markup

  - how is text represented and interacted with?
  - WYSIWYG
    - examples: notion
    - pros
      - low friction
      - drag and drop image upload is easy
    - cons
      - a lot more code to implement
      - every WYSIWYG editor is janky in some sui generis, hard to describe way
        - Markdown shortcuts that don't work
        - backspacing into formatting applies the formatting to new text you write
        - indenting/dedenting lists can be a pain
      - more complex stuff is often catastrophically hard to implement
        - e.g. the full power of HTML tables (with colspan, rowspan) requires essentially a full-blown spreadsheet engine to implement
        - in XML it just requires... parsing
      - change preview is harder
        - diffing markdown is 1) easy and 2) meaningful
        - diffing a JSON blob of a ProseMirror AST is not
        - showing deltas on rendered HTML is very hard
        - as a consequence, easy to mess something up and not see it
  - Markdown
    - examples: obsidian
    - pros
      - constrained
        - constraints liberate and liberties constrain
        - a lot of the things you can't do in markup you probably shouldn't do
        - forces you to keep it simple
      - well-known
      - widely implemented
        - markdown parsing isn't as easy as throwing a grammar at a parser generator
        - still, markdown parsers are widely available
      - covers most of what you need
      - change preview is easy
        - viewing a markdown diff, it's easy to mentally render what the changes would be
    - cons
      - not extensible
        - wikilinks require hacking the parser
        - or abusing link syntax
        - you can try embedding HTML, but you can't have markdown inside the HTML
      - the UX for plain-text editing of markdown varies widely
        - some editors have a Markdown mode that understands the syntax so it knows e.g. how to indent lists
        - Emacs has `fill-paragraph` that makes the resulting documents far more readable.
  - XML
    - pros:
      - extensible
        - wikilinks, shortcodes, etc, are just a new element type
        - graphviz? new node type
        - embedded plantuml? new node type
        - embedded gnuplot? new node type
      - widely implemented
      - complex markup is trivial
        - things that are impossible with markdown are trivial in XML
        - for example, tables as complex as what you can do in HTML are trivial to do in XML
        - can have deep structure e.g. TEI or standard ebooks markup
    - cons:
      - verbose
        - this is the thing that killed xml in addition to people trying to use it for data
        - something as simple as a bulleted list in Markdown requires endless typing in XML
        - paragraphs have to be explicitly demarcated, which really, really fucks with the flow of writing
        - links are tedious to write: instead of `[[Foo]]` you have to write `<link to="Foo" />`
        - instead of `[[Foo|link text]]` you have to write `<link to="Foo">link text</link>`
        - no good!
      - bad editing experience
        - most text editors have an XML mode
        - but it is very much neglected
        - something as simple as "complete the closing node when I type `</`" is usually not implemented
        - simple stuff like indenting the nodes so that the text is on a different line than the markup, like so (example), is very hard
  - MDX
    - what if we could have the simplicity of markdown for common use cases, and the generality of XML for complex use cases?
    - it exists: it's called MDX
    - pros
      - does exactly what I want
      - common things are quick
      - complex things are possible
    - cons:
      - not widely implemented
      - javascript
  - other formats
    - asciidoc
    - textile
    - creole
    - Mediawiki markup

- links
  - none
    - no links
    - the wiki is just a collection of documents
    - examples:
      - cardfile from the late 80s windows
      - reality
  - one way
    - links are unidirectional
    - examples: html
  - two-way
    - pages know which pages link to them
    - examples:
      - wikipedia, surprisingly (link to blog post)
      - anything post-Roam
  - typed links
    - links have metadata
    - examples:
      - obsidian dataview: <https://blacksmithgu.github.io/obsidian-dataview/>
      - notion, at the property level
    - e.g. `The book was written by [[Vladimir Nabokov]]{type=author}`.
  - mixin: red links
    - let you create links to non-existent pages
    - examples: wikipedia, notion
    - clicking on the link creates the page
    - ideally, have a way to find all red links in the database
  - mixin: link integrity
    - examples: none that i know of
    - deleting a page will fail if it would break existing links
