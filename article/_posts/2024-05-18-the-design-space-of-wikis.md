---
title: The Design Space of Wikis
summary: etc.
---

- object structure
  - plain text
    - an object's contents are plain, unformatted text
    - plain text conventions are used for "formatting"
    - links are just text
  - plain text with links
    - plain text
    - but with specific markup for links
  - formatted text
    - simple formatting: bold, lists, etc.
  - rich text with metadata
    - example: notion
    - typed properties aside from the text
    - "main text" remains a privileged own thing
  - typed properties
    - "main text" no longer a privileged thing
    - an object is a map of property names to values
    - some values may be rich text
  - mixin: fixed-length content
    - to simulate the limitations of paper
    - content may be limited to some fixed length
    - examples: none that i know of
- identifiers
  - unreadable identifiers
    - uuids
    - make it possible to rename things in a consequence free fashion
    - usually have to be hidden, requires WYSIWYG editing and a database
    - examples: notion
  - unique title
    - the object title is globally unique
    - this makes it easy to reference objects in a plain-text wiki: you just write the name
    - examples: wikipedia
- storage
  - files
    - plain-text files in a folder
    - examples:
      - obsidian
      - jekyll and any ssg
      - ikiwiki
      - gitit
    - pros
      - version control for free
        - can track changes in git
      - change review
        - for collaborative wikis, changes can be proposed in PRs
      - multi-file changes
        - with git, changes can apply to multiple files
          - this is unique to git
    - cons
  - database
- markup
  - WYSIWYG
    - examples: notion
    - pros
      - low friction
      - drag and drop image upload is easy
    - cons
      - a lot more code to implement
      - every WYSIWYG editor is janky in some sui generis, hard to describe way
        - Markdown shortcuts that don't work
        - backspacing into formatting applies the formatting to new text you write
        - indenting/dedenting lists can be a pain
      - more complex stuff is often catastrophically hard to implement
        - e.g. the full power of HTML tables (with colspan, rowspan) requires essentially a full-blown spreadsheet engine to implement
        - in XML it just requires... parsing
      - change preview is harder
        - diffing markdown is 1) easy and 2) meaningful
        - diffing a JSON blob of a ProseMirror AST is not
        - showing deltas on rendered HTML is very hard
        - as a consequence, easy to mess something up and not see it
  - Markdown
    - examples: obsidian
    - pros
      - constrained
        - constraints liberate and liberties constrain
        - a lot of the things you can't do in markup you probably shouldn't do
        - forces you to keep it simple
      - well-known
      - widely implemented
        - markdown parsing isn't as easy as throwing a grammar at a parser generator
        - still, markdown parsers are widely available
      - covers most of what you need
      - change preview is easy
        - viewing a markdown diff, it's easy to mentally render what the changes would be
    - cons
      - not extensible
        - wikilinks require hacking the parser
        - or abusing link syntax
      - the UX for plain-text editing of markdown varies widely
        - some editors have a Markdown mode that understands the syntax so it knows e.g. how to indent lists
        - Emacs has `fill-paragraph` that makes the resulting documents far more readable.
  - XML
  - MDX
- links
  - none
  - one way
  - two-way
  - typed links
  - mixin: red links
    - let you create links to non-existent pages
    - examples: wikipedia, notion
    - clicking on the link creates the page
    - ideally, have a way to find all red links in the database
  - mixin: link integrity
    - examples: none that i know of
    - deleting a page will fail if it would break existing links
